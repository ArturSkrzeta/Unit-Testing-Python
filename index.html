	<!DOCTYPE HTML>

<html>
	<head>
		<title>Portfolio Artur Skrzeta</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="https://arturskrzeta.github.io/"><img src="images/avatar.png" alt="" style="margin-bottom:0px;"/></a></span>
					<h1 id="logo"><a href="https://arturskrzeta.github.io/">Artur Skrzeta</a></h1>
					<p>Data Analyst<br />
					+4 years experience</p>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Intro</a></li>
						<li><a href="#two">Features</a></li>
						<li><a href="#three">Demo</a></li>
						<li><a href="#four">Setup</a></li>
						<li><a href="#five">Source Code</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/artur-skrz%C4%99ta-010b23187/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/arturskrrr/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://github.com/ArturSkrzeta" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="mailto: arturskrzeta@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h2>Unit and Integration Testing</h2>

										<h3>Intro</h3>

										<p style="text-align: justify;">Writing code to a code that already exists in order to verify correctness of function's work.
											That makes us sure the code works in accordance to programmer assumptions and software requirements.
										</p>

										<h5>Kind of tests:</h5>
										<ul>
											<li><b>Unit test</b> - tests single unit of application f.e. we compare if a function returns expexted value or expected data type.</li>
											<li><b>Integration test</b> - tests interaction between modules being combined as a one group.</li>
											<li><b>End2End test</b> - tests from the end user’s experience by simulating the real user scenario.</li>
										</ul>

										<h5>When what test:</h5>
										<ul>
											<li>We use unit test when we want to test the logical side of the code without any calls to external services.</li>
											<li>Integration tests are supposed to test functionality with a broader perspective, almost mimicking the behavior of a user.
													Because they connect to external systems and services, they take longer to run.
											</li>
											<li>Simply put, We want to have a lot of unit tests that run quickly and all the time, and have integration tests running less often (for instance, on any new merge request)</li>
										</ul>

									</header>
								</div>
							</section>

						<!-- Two -->
							<section id="two">
								<div class="container">
									<h3>Features</h3>
									<p>App includes following features:</p>
									<ul class="feature-icons">
										<li class="icon solid fa-check">Unit Tests</li>
										<li class="icon solid fa-check">Integration Tests</li>
									</ul>
								</div>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="container">
									<h3>Demo</h3>

									<h5>App testing:</h5>
									<ul>
										<li>Application manages Blogs and its Posts.</li>
										<li>Application is fed with data using JSON files.</li>
										<li>Performing tests, I provide example data to module units i.e. functions and compare outcome with expected values.</li>
										<li>I test application's single units:
											<br>
											- testing class instantiation,<br>
											- testing values returned by functions.
										</li>
										<li>I test application's integration:
											<br>
												- testing integration between classes,<br>
												- testing main application methods.
										</li>
									</ul>
									<img src="images/console.JPG" width="680">
									<ul>
										<li>All 12 test passed successfully.</li>
									</ul>

									<h5>Theory of Mocking:</h5>
									<ul>
										<li>There are applications that connect to external services as databases, storage services, external APIs, cloud services, and so on.</li>
										<li>However, in our unit test we don't want to connect any database or issue HTTP request or send email notification every time we test our code.
											 	Thing we want to test is the pure logic behind our code with unit tests qickly, often and with no latency.
										</li>
										<li>In this situation, we want to treat such code responsible for connecting with external service as <b>a mock object</b>.
												A mock object substitutes and imitates an object as close to the real object as possible.
												So in fact what we do is replacing an actuall call to the dependency with a mock object to make its bahaviour predictable.
												This way of mocking objects ensures control over the code’s behavior and espacially over unpredicted dependecies within a testing environment.
										</li>
										<li>In addition, mock object provides information about its usage, which can be inspected, such as if I have called it or how many times I have called a particular dependency tha has been mocked.</li>
										<li>With mocking an object we can prevent external dependencies from making a test fail.
												Let's take making HTTP requests to external service as the example.
												Test are being executed as expected only under the condition of a service's seccessful work.
												However, due to the fact the service is external and depends on an external infrastructure, it doesn't have to behave the same each time.
												Even a temporary change in the service's behaviour may cause a test's failure.
												In this case the solution is to replace such service with a mock object in order to simulate external service in a predictable way.
										</li>
									</ul>

									<h5>Mock's characteristics:</h5>
									<ul>
										<li>Mock object needs to simulate object that it replacs as close as possible.
											 	In order to get flexible enough, mock objct has so-called lazy attributes and methods that are created at the same time when we access them.
<!-- code area start -->
<pre>
from unittest.mock import Mock

mock = Mock()
print(mock.some_attribute)
print(mock.do_something())

service = mock
print(service.get_access().allow_admin())

-----------
# output
# Mock name='mock.some_attribute' id='4394778696'
# Mock name='mock.do_something()' id='4394778920'
# Mock name='mock.get_access().allow_admin()' id='5394778920'
</pre>
<!-- code area stop -->
											- Due to the fact mock creates arbitrary attributes and methods on the fly, it is suitable to replace any object.<br>
											- Notice that a returned value of each mocked method is also a Mock. In the case above mocked service with its mthods returned mock object as well.
											</li>
											<li>We can determine mocked functions's returned value up front.
													That way we can fix functions whose returned value may vary to one value that will be returned every time.
<!-- code area start -->
<pre>
import datetime
from unittest.mock import Mock

# Save a couple of test days
<span style="color:#fbff00;">tuesday</span> = datetime.datetime(year=2019, month=1, day=1)
<span style="color:#fbff00;">saturday</span> = datetime.datetime(year=2019, month=1, day=5)

# Mock datetime to control today's date
<span style="background-color:#a07927;">datetime = Mock()</span>

def is_weekday():
  today = datetime.datetime.today()
  # Python's datetime library treats Monday as 0 and Sunday as 6
  return (0 <= today.weekday() < 5)

# Mock .today() to return Tuesday
<span style="background-color:#a07927;">datetime.datetime.today.return_value = <span style="color:#fbff00;">tuesday</span></span>
# Test Tuesday is a weekday
assert is_weekday()

# Mock .today() to return Saturday
<span style="background-color:#a07927;">datetime.datetime.today.return_value = <span style="color:#fbff00;">saturday</span></span>
# Test Saturday is not a weekday
assert not is_weekday()
</pre>
<span style="font-size:12px;">source: realpython.com</span><br>
<!-- code area stop -->
											- in the example above, we mock <code>datetime</code> object and assign <code>return_value</code> of <code>tuesday</code>
												then <code>saturday</code>to mocked method <code>datetime.today()</code>
											</li>
									</ul>

									<h5>Coding some Mocks:</h5>
									<ul>
										<li>Lets take a function that returns a value that is undpredictable on each call. Here, word 'unpredictable' is used in terms of getting different results every time it runs:
<!-- code area start -->
<pre>
import random

def <span style="color:#00ffea">roll_dice() -> int</span>:
  return random.randint(1,6)

print(<span style="color:#00ffea">roll_dice()</span>)
print(<span style="color:#00ffea">roll_dice()</span>)
print(<span style="color:#00ffea">roll_dice()</span>)

-----------
# output
# 3
# 6
# 2
</pre>
<!-- code area stop -->
											- function returns number from range 1 - 6 inclusively.<br>
											- this function poses a certain level of unvertainity and should be mocked when we want to controll it when testing.
										</li>
										<li>Instantiating Mock type:
<!-- code area start -->
<pre>
from unittest import mock

<span style="color:#ffe200">mock_roll_dice</span> = mock.Mock(name="roll dice mock", return_value=1)
print(<span style="color:#ffe200">mock_roll_dice()</span>)

-----------
# output
# 1
</pre>
<!-- code area stop -->
										- we set a constant retured value of the function <b>mock_roll_dice</b>.
										</li>
										<li>Mocking the function:
<!-- code area start -->
<pre>
<span style="color:#00ffea">roll_dice</span> = <span style="color:#ffe200">mock_roll_dice</span>
print(<span style="color:#00ffea">roll_dice()</span>)

-----------
# output
# 1
</pre>
<!-- code area stop -->
										- from now on every time I call <b>roll_dice</b> function, it returns 1 every time (instrad randomnly integer froam the range) as it's the mock object right now.
										</li>
									</ul>

									<h5>Mocking objects in test environment:</h5>
									<ul>
										<li>Here is the Python app that we want to test:
<!-- code area start -->
<pre>
def <span style="color:#00ffea">roll_dice()</span>:
  return random.randint(1,6)

def <span style="color:#ff7eee">guess_num(num: int) -> int</span>:

  roll_num = <span style="color:#00ffea">roll_dice()</span>

  if roll_num == num:
    return "You won!"
  else:
    return "You lost!"

</pre>
<!-- code area stop -->
										</li>
										<li>Actual test:
<!-- code area start -->
<pre>
from unittest import mock
from game import <span style="color:#ff7eee">guess_num</span>

@mock.patch("game.<span style="color:#00ffea">roll_dice</span>")
def test_guess_num(<span style="color:#ffe200">mock_roll_dice</span>):
  <span style="color:#ffe200">mock_roll_dice</span>.return_value = 3
  assert.<span style="color:#ff7eee">guess_num(</span>3<span style="color:#ff7eee">)</span> == "You won!"

</pre>
<!-- code area stop -->
										- In the decorator we indicate a function <b>roll_dice</b> (to be mocked) that is in the local scope of the function that we actually test - in this case  <b>guess_num</b> function of <b>game</b> module.<br>
										- Indicating function in the decorator passes its corresponding mock object to the unit test.<br>
										- Function <b>test_guess_num</b> recieves it as <b>mock_roll_dice</b> then we can assign <b>return_value</b> of 3 to this mock object.<br>
										- With this solution, we replace <b>roll_dice</b> function with another mocked object that throws 3 each time.<br>
										- Then, calling <b>guess_num</b> with parameter of 3, we will always be winning getting "You won!" every time, getting test passed.
										</li>
									</ul>

								</div>
							</section>

						<!-- Four -->
							<section id="four">
								<div class="container">
									<h3>Setup</h3>
									<h5>Python libraries installation required:</h5>
									<code>pip install unittest2</code><br>
								</div>
							</section>

							<section id="five">
								<div class="container">
									<h3>Source Code</h3>
									<p>You can view the source code: <a href="https://github.com/ArturSkrzeta/Unit-and-Integration-Tests-in-Python/tree/master/pyproject">HERE</a></p>
									<p>&nbsp</p>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<a href="https://arturskrzeta.github.io/" style="padding-bottom:10px;">Back to Portfolio</a>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
